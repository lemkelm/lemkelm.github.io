<!DOCTYPE html>
<html>

    <head>
        <meta http-equiv='cache-control' content='no-cache'>
        <meta http-equiv='expires' content='0'>
        <meta http-equiv='pragma' content='no-cache'>
        <meta charset="utf-8">
        <title>Rating</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

        <!--   <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@1.1.3/dist/chartjs-plugin-dragdata.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/roughjs@3.1.0/dist/rough.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-rough@latest/dist/chartjs-plugin-rough.min.js"></script>-->
        <script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.6.0/chart.min.js"></script>
        <!--  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.2.1/chart.min.js"></script>-->
        <script
            src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@2.2.3/dist/chartjs-plugin-dragdata.min.js"></script>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.2.0/chartjs-plugin-datalabels.min.js"
            integrity="sha512-JPcRR8yFa8mmCsfrw4TNte1ZvF1e3+1SdGMslZvmrzDYxS69J7J49vkFL8u6u8PlPJK+H3voElBtUCzaXj+6ig=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>



        <style>
            html,
            body {
                margin: 0;
                padding: 0;
            }



            .chart {
                width: 1000px;
                height: 1000px;
                margin: 0 auto;
            }

            #myChart {
                z-index: 0;



            }

            #canvas {
                z-index: 1;


                position: absolute;
                top: 100px;
                left: 100px;
            }

            #newcanvas {
                z-index: 1;


                position: absolute;
                top: 100px;
                left: 100px;
            }


            #sealcanvas {
                z-index: 3;

                pointer-events: none;
                position: absolute;
                top: 0;
                left: 0;
            }

            #totalcanvas {
                z-index: 1;
                position: relative;
                top: -530px;
                left: 475px;

                pointer-events: none;
            }


            .inputs {
                margin: 0 auto;
                padding: 10px;


            }

        </style>
    </head>

    <body>

        <div class="inputs">
            <input type="number" id="value0" min="0" max="10" onkeypress="return isNumeric(event)"
                oninput="maxLengthCheck(this)"
                onKeyUp="if(this.value>10){this.value='10';}else if(this.value<0){this.value='0';}">
            <input type="number" id="value1" min="0" max="10" onkeypress="return isNumeric(event)"
                oninput="maxLengthCheck(this)"
                onKeyUp="if(this.value>10){this.value='10';}else if(this.value<0){this.value='0';}">
            <input type="number" id="value2" min="0" max="10" onkeypress="return isNumeric(event)"
                oninput="maxLengthCheck(this)"
                onKeyUp="if(this.value>10){this.value='10';}else if(this.value<0){this.value='0';}">
            <input type="number" id="value3" min="0" max="10" onkeypress="return isNumeric(event)"
                oninput="maxLengthCheck(this)"
                onKeyUp="if(this.value>10){this.value='10';}else if(this.value<0){this.value='0';}">
            <input type="number" id="value4" min="0" max="10" onkeypress="return isNumeric(event)"
                oninput="maxLengthCheck(this)"
                onKeyUp="if(this.value>10){this.value='10';}else if(this.value<0){this.value='0';}">
            <input type="number" id="value5" min="0" max="10" onkeypress="return isNumeric(event)"
                oninput="maxLengthCheck(this)"
                onKeyUp="if(this.value>10){this.value='10';}else if(this.value<0){this.value='0';}">
            <input type="text" id="valuetotal" readonly="readonly">
            <a id="link">Update</a>

        </div>
        <div class="chart">

            <canvas id="myChart"></canvas>
            <canvas id="totalcanvas"></canvas>
            <!-- <canvas id="sealcanvas"></canvas>
            <canvas id="canvas"></canvas> -->
            <canvas id="newcanvas"></canvas>

        </div>



        <script>




            const data0 = 10;
            const data1 = 9;
            const data2 = 3;
            const data3 = 5;
            const data4 = 2;
            const data5 = 3;
            const datatotal = (data0 + data1 + data2 + data3 + data4 + data5) / 6;
            datatotal.value = Math.round((datatotal + Number.EPSILON) * 100) / 100;

            const value0 = document.getElementById('value0');
            const value1 = document.getElementById('value1');
            const value2 = document.getElementById('value2');
            const value3 = document.getElementById('value3');
            const value4 = document.getElementById('value4');
            const value5 = document.getElementById('value5');
            const valuetotal = document.getElementById('valuetotal');

            chartvaluetotal(valuetotal.value);

            const labels = [['Story', value0.value], ['Pacing', value1.value], ['Visual', value2.value], ['Accessiblity', value3.value], ['Audio', value4.value], ['Gameplay', value5.value]];

            function maxLengthCheck(object) {
                if (object.value.length > object.max.length)
                    object.value = object.value.slice(0, object.max.length)
            }

            function isNumeric(evt) {
                var theEvent = evt || window.event;
                var key = theEvent.keyCode || theEvent.which;
                key = String.fromCharCode(key);
                var regex = /[0-9]/;
                if (!regex.test(key)) {
                    theEvent.returnValue = false;
                    if (theEvent.preventDefault) theEvent.preventDefault();
                }
            }


            let width, height, gradient;
            function getGradient(ctx, chartArea) {
                //     const chartArea = ctx.chart.chartArea;
                if (!chartArea) {
                    // This case happens on initial chart load
                    return;
                }

                const chartWidth = chartArea.right - chartArea.left;
                const chartHeight = chartArea.bottom - chartArea.top;
                if (!gradient) {
                    // Create the gradient because this is either the first render
                    // or the size of the chart has changed
                    width = chartWidth;
                    height = chartHeight;
                    const centerX = (chartArea.left + chartArea.right) / 2;
                    const centerY = (chartArea.top + chartArea.bottom) / 2;
                    const r = Math.min(
                        (chartArea.right - chartArea.left) / 2,
                        (chartArea.bottom - chartArea.top) / 2
                    );
                    //  gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, r);
                    gradient.addColorStop(0, "black");
                    gradient.addColorStop(0.1, "red");
                    gradient.addColorStop(0.4, "yellow");
                    gradient.addColorStop(1, "green");

                    /* gradient.addColorStop(0, "red");
                    gradient.addColorStop(0.15, "orange");
                    gradient.addColorStop(0.3, "yellow");
                    gradient.addColorStop(0.5, "green");
                    gradient.addColorStop(0.7, "blue");
                    gradient.addColorStop(0.85, "indigo");
                    gradient.addColorStop(1, "violet");*/

                }

                return gradient;
            }


            const colors = ["red", "yellow", "green"];


            const data = {
                labels: labels,
                datasets: [
                    {
                        label: 'main',
                        data: [data0, data1, data2, data3, data4, data5],
                        fill: 'origin',


                        //   borderColor: 'rgba(255, 99, 132, 1)',
                        borderColor: function (context) {
                            const chart = context.chart;
                            const { ctx, chartArea } = chart;

                            if (!chartArea) {
                                // This case happens on initial chart load
                                return;
                            }
                            return getGradient(ctx, chartArea);
                        },

                        /*
                                            borderColor: function (context) {
                                                let c = colors[context.dataIndex];
                                                if (!c) {
                                                    return;
                                                }
                                                if (context.active) {
                                                    c = helpers.getHoverColor(c);
                                                }
                                                const mid = helpers.color(c).desaturate(0.2).darken(0.2).rgbString();
                                                const start = helpers.color(c).lighten(0.2).rotate(270).rgbString();
                                                const end = helpers.color(c).lighten(0.1).rgbString();
                                                return createRadialGradient3(context, start, mid, end);
                                            },
                        */

                        borderWidth: 4,
                        pointHitRadius: 50,

                        // backgroundColor: "#8E24AA44",

                        backgroundColor: "#33333344",


                        pointBorderColor: "#000",
                        pointBackgroundColor: "rgba(1,250,48,1)",
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'black',
                        //     pointStyle: 'crossRot',
                        pointRadius: 4,
                        pointHoverRadius: 10,





                        datalabels: {
                            color: 'black',
                            font: {
                                weight: 'bold'
                            },


                        },
                        order: 1
                    },
                    {
                        label: 's1',
                        backgroundColor: '#fff',
                        borderColor: 'transparent',
                        pointRadius: 0,
                        data: [-2, -2, -2, -2, -2, -2],
                        fill: true,
                        order: 2
                    },
                    {
                        label: 's2',
                        backgroundColor: '#ff000011',
                        borderColor: 'transparent',
                        pointRadius: 0,
                        data: [2, 2, 2, 2, 2, 2],
                        fill: '-1',
                        order: 3
                    },
                    {
                        label: 's3',
                        backgroundColor: '#ffff0011',
                        borderColor: 'transparent',
                        pointRadius: 0,
                        data: [5, 5, 5, 5, 5, 5],
                        fill: '-1',
                        order: 4
                    },
                    {
                        label: 's4',
                        backgroundColor: '#00b05011',
                        borderColor: 'transparent',
                        pointRadius: 0,
                        data: [10, 10, 10, 10, 10, 10],
                        fill: '-1',
                        order: 5
                    },
                ]
            };


            /*
            //      (function () {
            function seal2() {
                //  const ctx = document.getElementById("sealcanvas").getContext("2d");
                const canvas = document.getElementById("myChart");
                const ctx = canvas.getContext("2d");

                //    canvas.height = 1000;
                //   canvas.width = 1000;




                const sealimg = new Image(); // Create new img element
                sealimg.addEventListener(
                    "load",
                    () => {
                        // execute drawImage statements here
                        ctx.drawImage(sealimg, 0, 0, sealimg.width, sealimg.height);
                    },
                    false
                );
                sealimg.src = "sealsit.png"; // Set source path

                var down = false;
                ctx.canvas.addEventListener('mousedown', function () { down = true; }, false);
                ctx.canvas.addEventListener('mouseup', function () { down = false; }, false);
                ctx.canvas.addEventListener('mousemove', function (event) {
                    if (down) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        //updateChartValue()
                        ctx.translate(sealimg.width / 2 * -1, sealimg.height / 2 * -1);
                        ctx.drawImage(sealimg, event.clientX - this.offsetLeft,
                            event.clientY - this.offsetTop, sealimg.width, sealimg.height);
                        ctx.translate(sealimg.width / 2, sealimg.height / 2);
                    }
                }, false);
            }

            seal2();
            //      })();
*/

            const sealimg = new Image();
            sealimg.src = "sealsit.png";




            const config = {
                type: 'radar',
                data,
                plugins: [ChartDataLabels,
                    {
                        afterLayout: chart => {
                            chart.getDatasetMeta(0).rScale._pointLabelItems.forEach(o => o.textAlign = 'center');
                        }
                    },
                    {
                        id: 'customImage',
                        beforeDraw: (chart) => {
                            /*
                            const ctx = chart.ctx;
                            sealimg.addEventListener(
                                "load",
                                () => {
                                    // execute drawImage statements here
                                    ctx.drawImage(sealimg, 0, 0, sealimg.width, sealimg.height);
                                },
                                false
                            );
                            sealimg.src = "sealsit.png"; // Set source path

                            var down = false;
                            ctx.addEventListener('mousedown', function () { down = true; }, false);
                            ctx.addEventListener('mouseup', function () { down = false; }, false);
                            ctx.addEventListener('mousemove', function (event) {
                                if (down) {
                                    ctx.clearRect(0, 0, sealimg.width, canvas.height);
                                    //    updateChartValue()
                                    ctx.translate(sealimg.width / 2 * -1, sealimg.height / 2 * -1);
                                    ctx.drawImage(sealimg, event.clientX - this.offsetLeft,
                                        event.clientY - this.offsetTop, sealimg.width, sealimg.height);
                                    ctx.translate(sealimg.width / 2, sealimg.height / 2);
                                }
                            }, false);
*/

                            /*
                                                        if (sealimg.complete) {
                                                            const ctx = chart.ctx;
                                                            const {
                                                                top,
                                                                left,
                                                                width,
                                                                height
                                                            } = chart.chartArea;
                                                            const x = left + width / 2 - sealimg.width / 2;
                                                            const y = top + height / 2 - sealimg.height / 2;
                                                            ctx.drawImage(sealimg, x, y);
                                                        } else {
                                                            sealimg.onload = () => chart.draw();
                                                        }
                            */


                        }

                    },
                ],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: function (e) {
                        const point = e.chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, false)
                        if (point.length) e.native.target.style.cursor = 'grab'
                        else e.native.target.style.cursor = 'default'
                    },
                    layout: {
                        padding: 0
                    },
                    scales: {
                        r: {
                            max: 10,
                            min: -2,
                            beginAtZero: true,

                            drawTicks: false,
                            weight: 0,
                            border: {
                                color: 'green',
                                width: 5
                            },

                            angleLines: {
                                //  color: 'red'
                                color: ['red', 'orange', 'gold', 'green', 'blue', 'indigo'],
                            },
                            grid: {

                                //   color: ['blue', 'cyan', 'chartreuse']
                                color: function (context) {
                                    const chart = context.chart;
                                    const { ctx, chartArea } = chart;

                                    if (!chartArea) {
                                        // This case happens on initial chart load
                                        return;
                                    }
                                    return getGradient(ctx, chartArea);
                                },
                            },
                            pointLabels: {
                                color: 'black',
                                // color: ['red', 'orange', 'gold', 'green', 'blue', 'indigo'],
                                padding: 20,
                                font: {
                                    size: 30,

                                }
                            },
                            ticks: {
                                color: 'red',
                                //   color: ['red', 'green', 'yellow'],
                                display: false,
                                count: 10,
                                stepSize: 1,
                                backdropPadding: {
                                    x: 0,
                                    y: 0
                                },
                                showLabelBackdrop: false,
                            }
                        }


                    },
                    plugins: {
                        filler: {
                            propagate: true
                        },
                        title: {
                            display: true,
                            align: "start",
                            text: ""
                        },
                        legend: {
                            align: "start",
                            display: false,


                        },
                        tooltip: {
                            enabled: false,
                        },
                        datalabels: {

                        },
                        dragData: {
                            round: 0,
                            showTooltip: false,
                            onDragStart: function (e) {
                                // console.log(e)

                            },
                            onDrag: function (e, datasetIndex, index, value) {
                                e.target.style.cursor = 'grabbing'
                                // console.log(e, datasetIndex, index, value)
                                if (value < 0) return false // this only allows positive values

                            },
                            onDragEnd: function (e, datasetIndex, index, value) {
                                e.target.style.cursor = 'default'
                                console.log(datasetIndex, index, value);
                                myChart.data.datasets[0].data[index] = value;
                                console.log(myChart.data.datasets[0].data[index]);
                                // value1.addEventListener('change', updateChartValue);
                                //  updateChartValue();
                                const inputboxes = document.getElementById('value' + index);
                                inputboxes.value = value;

                                updateChartValue();

                            },
                            //		  magnet: {
                            //	    to: Math.round // to: (value) => value + 5
                            //    }
                        },
                        ChartDataLabels: {},



                    },



                },
            };

            const myChart = new Chart(

                document.getElementById('myChart'),
                config

            );







            value0.value = data0;
            value1.value = data1;
            value2.value = data2;
            value3.value = data3;
            value4.value = data4;
            value5.value = data5;
            valuetotal.value = (data0 + data1 + data2 + data3 + data4 + data5) / 6;
            valuetotal.value = Math.round((datatotal + Number.EPSILON) * 100) / 100;
            //value0.value + value1.value + value2.value + value3.value + value4.value + value5.value = datatotal;



            value0.addEventListener('change', updateChartValue);
            value1.addEventListener('change', updateChartValue);
            value2.addEventListener('change', updateChartValue);
            value3.addEventListener('change', updateChartValue);
            value4.addEventListener('change', updateChartValue);
            value5.addEventListener('change', updateChartValue);
            //valuetotal.addEventListener('change', updateChartValue);




            function updateChartValue() {

                var data0 = parseFloat(document.getElementById("value0").value);
                if (isNaN(data0)) data0 = 0;
                var data1 = parseFloat(document.getElementById("value1").value);
                if (isNaN(data1)) data1 = 0;
                var data2 = parseFloat(document.getElementById("value2").value);
                if (isNaN(data2)) data2 = 0;
                var data3 = parseFloat(document.getElementById("value3").value);
                if (isNaN(data3)) data3 = 0;
                var data4 = parseFloat(document.getElementById("value4").value);
                if (isNaN(data4)) data4 = 0;
                var data5 = parseFloat(document.getElementById("value5").value);
                if (isNaN(data5)) data5 = 0;
                var result = (data0 + data1 + data2 + data3 + data4 + data5) / 6;
                result = Math.round((result + Number.EPSILON) * 100) / 100;
                document.getElementById("valuetotal").value = result;

                chartvaluetotal(result);


                labels[0][1] = data0;
                labels[1][1] = data1;
                labels[2][1] = data2;
                labels[3][1] = data3;
                labels[4][1] = data4;
                labels[5][1] = data5;


                /*

                                var number0 = parseFloat(document.getElementById("value0").value);
                                if (isNaN(number0)) number0 = 0;
                                var number1 = parseFloat(document.getElementById("value1").value);
                                if (isNaN(number1)) number1 = 0;
                                var number2 = parseFloat(document.getElementById("value2").value);
                                if (isNaN(number2)) number2 = 0;
                                var number3 = parseFloat(document.getElementById("value3").value);
                                if (isNaN(number3)) number3 = 0;
                                var number4 = parseFloat(document.getElementById("value4").value);
                                if (isNaN(number4)) number4 = 0;
                                var number5 = parseFloat(document.getElementById("value5").value);
                                if (isNaN(number5)) number5 = 0;
                                var result = number0 + number1 + number2 + number3 + number4 + number5;
                                document.getElementById("valuetotal").value = result;
                */


                myChart.data.datasets[0].data[0] = value0.value;
                myChart.data.datasets[0].data[1] = value1.value;
                myChart.data.datasets[0].data[2] = value2.value;
                myChart.data.datasets[0].data[3] = value3.value;
                myChart.data.datasets[0].data[4] = value4.value;
                myChart.data.datasets[0].data[5] = value5.value;
                myChart.update();
            }




            //  let canvas = document.getElementById("myChart");
            $(function () {

                var canvas = document.getElementById("canvas");
                var ctx = canvas.getContext("2d");


                canvas.height = 1000;
                canvas.width = 1000;
                //  function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
                function drawStar(spikes, outerRadius, innerRadius) {

                    var cx = canvas.width / 2;
                    var cy = canvas.height / 2;
                    var rot = Math.PI / 2 * 3;
                    var x = cx;
                    var y = cy;




                    var step = Math.PI / spikes;

                    ctx.beginPath();
                    ctx.moveTo(cx, cy - outerRadius)
                    for (i = 0; i < spikes; i++) {
                        x = cx + Math.cos(rot) * outerRadius;
                        y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y)
                        rot += step

                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y)
                        rot += step
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                    ctx.closePath();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'brown';
                    ctx.stroke();
                    ctx.fillStyle = 'gold';
                    ctx.fill();

                }
                function seal3() {
                    const img = new Image(); // Create new img element
                    img.addEventListener(
                        "load",
                        () => {
                            // execute drawImage statements here
                            ctx.drawImage(img, 0, 0, img.width, img.height);
                        },
                        false
                    );
                    img.src = "sealsit.png"; // Set source path

                    var down = false;
                    ctx.canvas.addEventListener('mousedown', function () { down = true; }, false);
                    ctx.canvas.addEventListener('mouseup', function () { down = false; }, false);
                    ctx.canvas.addEventListener('mousemove', function (event) {
                        if (down) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.translate(img.width / 2 * -1, img.height / 2 * -1);
                            ctx.drawImage(img, event.clientX - this.offsetLeft,
                                event.clientY - this.offsetTop, img.width, img.height);
                            ctx.translate(img.width / 2, img.height / 2);
                        }
                    }, false);
                }



                drawStar(5, 30, 18);
                seal3()

            }); // end $(function(){});


            $(function () {
                // get canvas related references
                const canvas = document.getElementById("newcanvas");
                const ctx = canvas.getContext("2d");
                const BB = canvas.getBoundingClientRect();
                const offsetX = BB.left;
                const offsetY = BB.top;
                const WIDTH = canvas.width;
                const HEIGHT = canvas.height;

                // drag related variables
                let dragok = false;
                let startX;
                let startY;

                // an array of objects that define different shapes
                const shapes = [];
                // define 2 rectangles
                shapes.push({
                    x: 10,
                    y: 100,
                    width: 30,
                    height: 30,
                    fill: "#444444",
                    isDragging: false
                });
                shapes.push({
                    x: 80,
                    y: 100,
                    width: 30,
                    height: 30,
                    fill: "#ff550d",
                    isDragging: false
                });
                // define 2 circles
                shapes.push({ x: 150, y: 100, r: 10, fill: "#800080", isDragging: false });
                shapes.push({ x: 200, y: 100, r: 10, fill: "#0c64e8", isDragging: false });

                // listen for mouse events
                canvas.onmousedown = myDown;
                canvas.onmouseup = myUp;
                canvas.onmousemove = myMove;

                // call to draw the scene
                draw();

                // draw a single rect
                function rect(r) {
                    ctx.fillStyle = r.fill;
                    ctx.fillRect(r.x, r.y, r.width, r.height);
                }

                // draw a single rect
                function circle(c) {
                    ctx.fillStyle = c.fill;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                }

                //     function drawStar2(cx, cy, spikes, outerRadius, innerRadius) {
                function drawStar2(r) {

                    var cx = r.x;
                    var cy = r.y;

                    //   var cx = canvas.width / 2;
                    //  var cy = canvas.height / 2;
                    var rot = Math.PI / 2 * 3;
                    var x = cx;
                    var y = cy;

                    var spikes = 5;
                    var outerRadius = 30;
                    var innerRadius = 18;



                    var step = Math.PI / spikes;

                    ctx.beginPath();
                    ctx.moveTo(cx, cy - outerRadius)
                    for (i = 0; i < spikes; i++) {
                        x = cx + Math.cos(rot) * outerRadius;
                        y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y)
                        rot += step

                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y)
                        rot += step
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                    ctx.closePath();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'brown';
                    ctx.stroke();
                    ctx.fillStyle = 'gold';
                    ctx.fill();
                }

                function seal4(r) {
                    const img = new Image(); // Create new img element
                    img.addEventListener(
                        "load",
                        () => {
                            // execute drawImage statements here
                            ctx.drawImage(img, 0, 0, img.width, img.height);
                        },
                        false
                    );
                    img.src = "sealsit.png"; // Set source path


                }


                // clear the canvas
                function clear() {
                    ctx.clearRect(0, 0, WIDTH, HEIGHT);
                }

                // redraw the scene
                function draw() {
                    clear();
                    // redraw each shape in the shapes[] array
                    for (let i = 0; i < shapes.length; i++) {
                        // decide if the shape is a rect or circle
                        // (it's a rect if it has a width property)
                        if (shapes[i].width) {
                            //       rect(shapes[i]);
                            seal4(shapes[i]);
                        } else {
                            drawStar2(shapes[i]);
                            //     circle(shapes[i]);
                        }
                    }
                }

                // handle mousedown events
                function myDown(e) {
                    // tell the browser we're handling this mouse event
                    e.preventDefault();
                    e.stopPropagation();

                    // get the current mouse position
                    const mx = parseInt(e.clientX - offsetX);
                    const my = parseInt(e.clientY - offsetY);

                    // test each shape to see if mouse is inside
                    dragok = false;
                    for (let i = 0; i < shapes.length; i++) {
                        var s = shapes[i];
                        // decide if the shape is a rect or circle
                        if (s.width) {
                            // test if the mouse is inside this rect
                            if (
                                !dragok &&
                                mx > s.x &&
                                mx < s.x + s.width &&
                                my > s.y &&
                                my < s.y + s.height
                            ) {
                                // if yes, set that rects isDragging=true
                                dragok = true;
                                s.isDragging = true;
                            }
                        } else {
                            const dx = s.x - mx;
                            const dy = s.y - my;
                            // test if the mouse is inside this circle
                            if (!dragok && dx * dx + dy * dy < s.r * s.r) {
                                dragok = true;
                                s.isDragging = true;
                            }
                        }
                    }
                    // save the current mouse position
                    startX = mx;
                    startY = my;
                }

                // handle mouseup events
                function myUp(e) {
                    // tell the browser we're handling this mouse event
                    e.preventDefault();
                    e.stopPropagation();

                    // clear all the dragging flags
                    dragok = false;
                    for (let i = 0; i < shapes.length; i++) {
                        shapes[i].isDragging = false;
                    }
                }

                // handle mouse moves
                function myMove(e) {
                    // if we're dragging anything...
                    if (dragok) {
                        // tell the browser we're handling this mouse event
                        e.preventDefault();
                        e.stopPropagation();

                        // get the current mouse position
                        const mx = parseInt(e.clientX - offsetX);
                        const my = parseInt(e.clientY - offsetY);

                        // calculate the distance the mouse has moved
                        // since the last mousemove
                        const dx = mx - startX;
                        const dy = my - startY;

                        // move each rect that isDragging
                        // by the distance the mouse has moved
                        // since the last mousemove
                        for (let i = 0; i < shapes.length; i++) {
                            const s = shapes[i];
                            if (s.isDragging) {
                                s.x += dx;
                                s.y += dy;
                            }
                        }

                        // redraw the scene with the new rect positions
                        draw();

                        // reset the starting mouse position for the next mousemove
                        startX = mx;
                        startY = my;
                    }
                }

            });



            function chartvaluetotal(value) {

                //  const ctx = document.getElementById("totalcanvas").getContext("2d");

                const canvas = document.getElementById("totalcanvas");
                const ctx = canvas.getContext("2d");

                canvas.height = 100;
                canvas.width = 100;
                //    top:365
                //     left:375

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const textvalue = value;


                ctx.font = "30px sans-serif";
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                //  ctx.textAlign = "center";
                ctx.fillText(textvalue, canvas.width / 2, canvas.height / 2);
            }

            (function () {
                const canvas = document.getElementById('sealcanvas');
                const context = canvas.getContext('2d');

                // resize the canvas to fill browser window dynamically
                window.addEventListener('resize', resizeCanvas, false);

                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    /**
                     * Your drawings need to be inside this function otherwise they will be reset when
                     * you resize the browser window and the canvas goes will be cleared.
                     */

                    //          seal();
                }

                resizeCanvas();



                function seal() {
                    //  const ctx = document.getElementById("sealcanvas").getContext("2d");
                    const canvas = document.getElementById("sealcanvas");
                    const ctx = canvas.getContext("2d");

                    canvas.height = 1000;
                    canvas.width = 1000;




                    const img = new Image(); // Create new img element
                    img.addEventListener(
                        "load",
                        () => {
                            // execute drawImage statements here
                            ctx.drawImage(img, 0, 0, img.width, img.height);
                        },
                        false
                    );
                    img.src = "sealsit.png"; // Set source path

                    var down = false;
                    ctx.canvas.addEventListener('mousedown', function () { down = true; }, false);
                    ctx.canvas.addEventListener('mouseup', function () { down = false; }, false);
                    ctx.canvas.addEventListener('mousemove', function (event) {
                        if (down) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.translate(img.width / 2 * -1, img.height / 2 * -1);
                            ctx.drawImage(img, event.clientX - this.offsetLeft,
                                event.clientY - this.offsetTop, img.width, img.height);
                            ctx.translate(img.width / 2, img.height / 2);
                        }
                    }, false);
                }


                seal();


            })();













            async function autoDownloadCanvas() {
                let link = document.getElementById('link');
                link.setAttribute('download', 'example.png');
                link.setAttribute('href', canvas.toDataURL("image/png"));
                link.click();
            }
            //  autoDownloadCanvas()

            function download() {
                var link = document.createElement('a');
                link.download = 'filename.png';
                link.href = document.getElementById('myChart').toDataURL('image/png')
                link.click();
            }

            //     download();

            console.log(myChart)
        </script>










    </body>

</html>
